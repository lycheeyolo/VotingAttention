# 目标中心注意力机制（Target-Centric Attention）：投票模型

## 核心思想：投票与聚合

您提出的机制可以完美地映射为一个 **“投票系统”**。在这个系统中，每个 Token 既是投票者（Voter），也是候选人（Candidate）。

**1. 投票阶段 (The Voting Phase)**

- **规则**：序列中的每一个 Token $i$（作为投票者）都拥有 1.0 单位 的总票数。

- **分配**：它根据相关性（ $Q$ 和 $K$ 的匹配），将这 1.0 票按不同比例分给序列中的所有 Token $j$（作为候选人）。

- **数学约束**：这就要求对每一行（每个投票者）进行 Softmax 归一化，确保票数之和为 1。

**2. 聚合阶段 (The Aggregation Phase)**

- **规则**：对于每一个 Token $j$（作为候选人），它的新表示是它收到的所有“选票”的总和。

- **选票的价值 ($V$)**：这里我们引入 Value ($V$) 矩阵。一张“选票”不仅仅是一个计数值，它携带了投票者 $i$ 想要贡献给候选人的具体资源 $V_i$。

- **结果**：如果 Token $j$ 很重要，很多人给它投票，它收到的 $V$ 向量叠加起来就会很强；反之则很弱。

## 具体公式推导

我们使用三个向量：

- **$Q$ (Query)**: 投票者的意向（决定投给谁）。

- **$K$ (Key)**: 候选人的特征（用来吸引投票）。

- **$V$ (Value)**: 实际贡献的内容（票里的资源）。

### 第一步：计算投票权重矩阵 $W$

首先计算每个 Token $i$ 投给 Token $j$ 的权重 $W_{i, j}$。

$$\text{Logits} = \frac{Q K^T}{\sqrt{d_k}}$$

对 **行（Row）** 进行 Softmax，确保每个 Token $i$ 发出的权重和为 1：

$$W = \text{Softmax}_{\text{row}}(\text{Logits})$$

此时：

$W_{i, j}$ 表示：Token $i$ 投给 Token $j$ 的票数比例。

$\sum_{j} W_{i, j} = 1$ （符合“一人一票”原则）。

### 第二步：计算新表示 $O'$ (加权聚合)

对于目标 Token $j$，它的新表示  O' $j$ 是所有投票者 i 的内容向量 $V_i$ 乘以其投给 j 的票数 $W_{i, j}$ 的总和。

**单点公式**：

$$O'_j = \sum_{i=1}^{N} \underbrace{W_{i, j}}_{\text{收到 } i \text{ 的票数}} \cdot \underbrace{V_i}_{\text{投票者 } i \text{ 的资源}}$$

**矩阵公式**：

为了并行计算所有 $j$ 的结果，我们将 $W$ 转置为 $W^T$，然后左乘 $V$。

$$\text{Output}' = W^T V$$

## 机制特性分析

**1. 解耦 (Decoupling) - 新特性**

引入 $V$ 后，模型可以将“寻址逻辑”与“内容传输”分离。

- **$Q$ 的作用**：决定“我觉得谁重要”。

- **$V$ 的作用**：决定“我把什么信息传给他”。

- **举例**：在一个句子中，修饰语（Token $i$）可能觉得主语（Token $j$）很重要（通过 $Q, K$ 匹配），然后将修饰语的具体语义特征（通过 $V$）传递给主语。

**2. 流量不守恒（Popularity Scaling）**

虽然每个人的发出票数总和是 1，但每个人收到的票数总和是不固定的。

- **热门 Token**：如果 Token $j$ 是句子的核心， $\sum_{i} W_{i, j}$ 远大于 1。这会自动放大该 Token 的特征向量。

- **边缘 Token**：如果 Token $j$ 是噪音，几乎没人给它投票，它的特征向量会被抑制。
